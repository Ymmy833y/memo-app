{"mappings":"ACAA,MAAM,EAAa,oBAGnB,KAAK,gBAAgB,CAAC,UAAW,AAAA,IAC/B,EAAM,SAAS,CACb,MAJmB,0BAKhB,IAAI,CAAC,AAAA,GAAY,EAAS,IAAI,IAC9B,IAAI,CAAC,AAAA,IAEJ,IAAI,EAAmB,OAAO,MAAM,CAAC,GAAU,GAAG,CAAC,AAAA,GAAO,IAAI,IAAI,EAAK,KAAK,QAAQ,EAAE,QAAQ,IAExF,EAAW,IAAI,IAAI,eAAgB,KAAK,QAAQ,EAAE,QAAQ,GAIhE,OAHK,EAAiB,QAAQ,CAAC,IAC7B,EAAiB,IAAI,CAAC,GAEjB,OAAO,IAAI,CAAC,GAAY,IAAI,CAAC,AAAA,GAC3B,QAAQ,GAAG,CAChB,EAAiB,GAAG,CAAC,AAAA,GACZ,EAAM,GAAG,CAAC,GAAK,KAAK,CAAC,AAAA,IAC1B,QAAQ,KAAK,CAAC,CAAC,cAAc,EAAE,EAAI,UAAU,CAAC,CAAE,GAEzC,QAAQ,OAAO,OAKhC,GACC,KAAK,CAAC,AAAA,IACL,QAAQ,KAAK,CAAC,iCAAkC,EAClD,GAEN,GAEA,KAAK,gBAAgB,CAAC,WAAY,AAAA,IAChC,EAAM,SAAS,CACb,OAAO,IAAI,GAAG,IAAI,CAAC,AAAA,GACV,QAAQ,GAAG,CAChB,EAAW,MAAM,CAAC,AAAA,GAAQ,IAAS,GAChC,GAAG,CAAC,AAAA,GAAQ,OAAO,MAAM,CAAC,MAIrC,GAEA,KAAK,gBAAgB,CAAC,QAAS,AAAA,IAEzB,EAAM,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,QAI/B,EAAM,WAAW,CACf,OAAO,KAAK,CAAC,EAAM,OAAO,CAAC,GAAG,EAAE,IAAI,CAAC,AAAA,GACnC,AAAI,GAGG,MAAM,EAAM,OAAO,EAAE,KAAK,CAAC,IAEhC,AAAI,AAAuB,aAAvB,EAAM,OAAO,CAAC,IAAI,CACb,OAAO,KAAK,CAAC,IAAI,IAAI,eAAgB,KAAK,QAAQ,EAAE,QAAQ,IAG9D,IAAI,SAAS,GAAI,CACtB,OAAQ,IACR,WAAY,sBACZ,QAAS,CAAE,eAAgB,YAAa,CAC1C,KAIR","sources":["<anon>","src/sw.js"],"sourcesContent":["const CACHE_NAME = 'memo-app-cache-v2';\nconst ASSET_MANIFEST = './parcel-manifest.json';\nself.addEventListener('install', (event)=>{\n    event.waitUntil(fetch(ASSET_MANIFEST).then((response)=>response.json()).then((manifest)=>{\n        // Convert manifest paths to absolute URLs\n        let urlsFromManifest = Object.values(manifest).map((url)=>new URL(url, self.location).toString());\n        // Always include index.html\n        const indexUrl = new URL('./index.html', self.location).toString();\n        if (!urlsFromManifest.includes(indexUrl)) urlsFromManifest.push(indexUrl);\n        return caches.open(CACHE_NAME).then((cache)=>{\n            return Promise.all(urlsFromManifest.map((url)=>{\n                return cache.add(url).catch((error)=>{\n                    console.error(`Failed to add ${url} to cache:`, error);\n                    // On error, skip and continue\n                    return Promise.resolve();\n                });\n            }));\n        });\n    }).catch((error)=>{\n        console.error('Failed to load asset manifest:', error);\n    }));\n});\nself.addEventListener('activate', (event)=>{\n    event.waitUntil(caches.keys().then((cacheNames)=>{\n        return Promise.all(cacheNames.filter((name)=>name !== CACHE_NAME).map((name)=>caches.delete(name)));\n    }));\n});\nself.addEventListener('fetch', (event)=>{\n    // Ignore WebSocket requests for HMR\n    if (event.request.url.includes('/ws')) return;\n    event.respondWith(caches.match(event.request.url).then((response)=>{\n        if (response) return response;\n        return fetch(event.request).catch(()=>{\n            // For navigation requests, return cached index.html\n            if (event.request.mode === 'navigate') return caches.match(new URL('./index.html', self.location).toString());\n            // Otherwise, return a 503 response\n            return new Response('', {\n                status: 503,\n                statusText: 'Service Unavailable',\n                headers: {\n                    'Content-Type': 'text/plain'\n                }\n            });\n        });\n    }));\n});\n\n//# sourceMappingURL=sw.js.map\n","const CACHE_NAME = 'memo-app-cache-v2';\nconst ASSET_MANIFEST = './parcel-manifest.json';\n\nself.addEventListener('install', event => {\n  event.waitUntil(\n    fetch(ASSET_MANIFEST)\n      .then(response => response.json())\n      .then(manifest => {\n        // Convert manifest paths to absolute URLs\n        let urlsFromManifest = Object.values(manifest).map(url => new URL(url, self.location).toString());\n        // Always include index.html\n        const indexUrl = new URL('./index.html', self.location).toString();\n        if (!urlsFromManifest.includes(indexUrl)) {\n          urlsFromManifest.push(indexUrl);\n        }\n        return caches.open(CACHE_NAME).then(cache => {\n          return Promise.all(\n            urlsFromManifest.map(url => {\n              return cache.add(url).catch(error => {\n                console.error(`Failed to add ${url} to cache:`, error);\n                // On error, skip and continue\n                return Promise.resolve();\n              });\n            })\n          );\n        });\n      })\n      .catch(error => {\n        console.error('Failed to load asset manifest:', error);\n      })\n  );\n});\n\nself.addEventListener('activate', event => {\n  event.waitUntil(\n    caches.keys().then(cacheNames => {\n      return Promise.all(\n        cacheNames.filter(name => name !== CACHE_NAME)\n          .map(name => caches.delete(name))\n      );\n    })\n  );\n});\n\nself.addEventListener('fetch', event => {\n  // Ignore WebSocket requests for HMR\n  if (event.request.url.includes('/ws')) {\n    return;\n  }\n\n  event.respondWith(\n    caches.match(event.request.url).then(response => {\n      if (response) {\n        return response;\n      }\n      return fetch(event.request).catch(() => {\n        // For navigation requests, return cached index.html\n        if (event.request.mode === 'navigate') {\n          return caches.match(new URL('./index.html', self.location).toString());\n        }\n        // Otherwise, return a 503 response\n        return new Response('', {\n          status: 503,\n          statusText: 'Service Unavailable',\n          headers: { 'Content-Type': 'text/plain' }\n        });\n      });\n    })\n  );\n});\n"],"names":["CACHE_NAME","self","addEventListener","event","waitUntil","fetch","then","response","json","manifest","urlsFromManifest","Object","values","map","url","URL","location","toString","indexUrl","includes","push","caches","open","cache","Promise","all","add","catch","error","console","resolve","keys","cacheNames","filter","name","delete","request","respondWith","match","mode","Response","status","statusText","headers"],"version":3,"file":"sw.js.map"}