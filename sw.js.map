{"mappings":"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","sources":["<anon>","src/sw.js"],"sourcesContent":["const CACHE_NAME = 'memo-app-cache-v2';\nconst ASSET_MANIFEST = './parcel-manifest.json';\n// List of external CDN URLs to cache\nconst CDN_URLS = [\n    'https://uicdn.toast.com/editor/latest/toastui-editor.min.css',\n    'https://uicdn.toast.com/editor/latest/theme/toastui-editor-dark.min.css',\n    'https://uicdn.toast.com/tui-color-picker/latest/tui-color-picker.min.css',\n    'https://uicdn.toast.com/editor-plugin-color-syntax/latest/toastui-editor-plugin-color-syntax.min.css',\n    'https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism.min.css',\n    'https://uicdn.toast.com/editor-plugin-code-syntax-highlight/latest/toastui-editor-plugin-code-syntax-highlight.min.css'\n];\nself.addEventListener('install', (event)=>{\n    event.waitUntil(// Fetch asset manifest and then add both local and CDN resources to the cache\n    fetch(ASSET_MANIFEST).then((response)=>response.json()).then((manifest)=>{\n        // Convert manifest paths to absolute URLs\n        let urlsFromManifest = Object.values(manifest).map((url)=>new URL(url, self.location).toString());\n        // Always include index.html\n        const indexUrl = new URL('./index.html', self.location).toString();\n        if (!urlsFromManifest.includes(indexUrl)) urlsFromManifest.push(indexUrl);\n        // Combine local assets with CDN resources\n        const allUrls = urlsFromManifest.concat(CDN_URLS);\n        return caches.open(CACHE_NAME).then((cache)=>{\n            return Promise.all(allUrls.map((url)=>{\n                const urlObj = new URL(url);\n                // Skip unsupported chrome-extension requests\n                if (urlObj.protocol === 'chrome-extension:') return Promise.resolve();\n                // For CDN URLs, fetch with no-cors mode and then cache\n                if (url.startsWith('https://uicdn.toast.com/')) return fetch(new Request(url, {\n                    mode: 'no-cors'\n                })).then((response)=>cache.put(url, response)).catch((error)=>{\n                    console.error(`Failed to cache ${url}:`, error);\n                    return Promise.resolve();\n                });\n                // For local assets, fetch normally and then cache\n                return fetch(url).then((response)=>cache.put(url, response)).catch((error)=>{\n                    console.error(`Failed to cache ${url}:`, error);\n                    return Promise.resolve();\n                });\n            }));\n        });\n    }).catch((error)=>{\n        console.error('Failed to load asset manifest:', error);\n    }));\n});\nself.addEventListener('activate', (event)=>{\n    event.waitUntil(caches.keys().then((cacheNames)=>{\n        return Promise.all(cacheNames.filter((name)=>name !== CACHE_NAME).map((name)=>caches.delete(name)));\n    }));\n});\nself.addEventListener('fetch', (event)=>{\n    // Ignore WebSocket requests for HMR and requests with chrome-extension scheme\n    const requestUrl = new URL(event.request.url);\n    if (event.request.url.includes('/ws') || requestUrl.protocol === 'chrome-extension:') return;\n    // Define destinations to use network-first strategy\n    const networkFirstDestinations = [\n        'document',\n        'script',\n        'style'\n    ];\n    // For navigation, script, and style requests, use network-first strategy.\n    if (event.request.mode === 'navigate' || networkFirstDestinations.includes(event.request.destination)) {\n        event.respondWith(fetch(event.request).then((response)=>{\n            console.log('[SW] Network fetch succeeded for:', event.request.url);\n            // Clone the response and update the cache\n            const clonedResponse = response.clone();\n            caches.open(CACHE_NAME).then((cache)=>{\n                cache.put(event.request, clonedResponse);\n            });\n            return response;\n        }).catch(()=>{\n            console.warn('[SW] Network fetch failed for:', event.request.url, ', attempting to serve from cache.');\n            // If network fetch fails, try to return the cached response\n            return caches.match(event.request).then((cachedResponse)=>{\n                if (cachedResponse) {\n                    console.log('[SW] Serving cached response for:', event.request.url);\n                    return cachedResponse;\n                }\n                // For navigation requests, fallback to cached index.html\n                if (event.request.mode === 'navigate') {\n                    console.warn('[SW] No cached response found, serving cached index.html for navigation request.');\n                    return caches.match(new URL('./index.html', self.location).toString());\n                }\n                console.error('[SW] No cached response available for:', event.request.url);\n                // Otherwise, return a 503 Service Unavailable response\n                return new Response('', {\n                    status: 503,\n                    statusText: 'Service Unavailable',\n                    headers: {\n                        'Content-Type': 'text/plain'\n                    }\n                });\n            });\n        }));\n        return;\n    }\n    // For all other requests, use cache-first strategy\n    event.respondWith(caches.match(event.request).then((response)=>{\n        if (response) {\n            console.log('[SW] Serving cached response for:', event.request.url);\n            return response;\n        }\n        return fetch(event.request).then((networkResponse)=>networkResponse).catch(()=>{\n            console.error('[SW] Failed to fetch:', event.request.url);\n            return new Response('', {\n                status: 503,\n                statusText: 'Service Unavailable',\n                headers: {\n                    'Content-Type': 'text/plain'\n                }\n            });\n        });\n    }));\n});\n\n//# sourceMappingURL=sw.js.map\n","const CACHE_NAME = 'memo-app-cache-v2';\nconst ASSET_MANIFEST = './parcel-manifest.json';\n\n// List of external CDN URLs to cache\nconst CDN_URLS = [\n  'https://uicdn.toast.com/editor/latest/toastui-editor.min.css',\n  'https://uicdn.toast.com/editor/latest/theme/toastui-editor-dark.min.css',\n  'https://uicdn.toast.com/tui-color-picker/latest/tui-color-picker.min.css',\n  'https://uicdn.toast.com/editor-plugin-color-syntax/latest/toastui-editor-plugin-color-syntax.min.css',\n  'https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism.min.css',\n  'https://uicdn.toast.com/editor-plugin-code-syntax-highlight/latest/toastui-editor-plugin-code-syntax-highlight.min.css'\n];\n\nself.addEventListener('install', event => {\n  event.waitUntil(\n    // Fetch asset manifest and then add both local and CDN resources to the cache\n    fetch(ASSET_MANIFEST)\n      .then(response => response.json())\n      .then(manifest => {\n        // Convert manifest paths to absolute URLs\n        let urlsFromManifest = Object.values(manifest).map(url => new URL(url, self.location).toString());\n        // Always include index.html\n        const indexUrl = new URL('./index.html', self.location).toString();\n        if (!urlsFromManifest.includes(indexUrl)) {\n          urlsFromManifest.push(indexUrl);\n        }\n        // Combine local assets with CDN resources\n        const allUrls = urlsFromManifest.concat(CDN_URLS);\n        return caches.open(CACHE_NAME).then(cache => {\n          return Promise.all(\n            allUrls.map(url => {\n              const urlObj = new URL(url);\n              // Skip unsupported chrome-extension requests\n              if (urlObj.protocol === 'chrome-extension:') {\n                return Promise.resolve();\n              }\n              // For CDN URLs, fetch with no-cors mode and then cache\n              if (url.startsWith('https://uicdn.toast.com/')) {\n                return fetch(new Request(url, { mode: 'no-cors' }))\n                  .then(response => cache.put(url, response))\n                  .catch(error => {\n                    console.error(`Failed to cache ${url}:`, error);\n                    return Promise.resolve();\n                  });\n              }\n              // For local assets, fetch normally and then cache\n              return fetch(url)\n                .then(response => cache.put(url, response))\n                .catch(error => {\n                  console.error(`Failed to cache ${url}:`, error);\n                  return Promise.resolve();\n                });\n            })\n          );\n        });\n      })\n      .catch(error => {\n        console.error('Failed to load asset manifest:', error);\n      })\n  );\n});\n\nself.addEventListener('activate', event => {\n  event.waitUntil(\n    caches.keys().then(cacheNames => {\n      return Promise.all(\n        cacheNames.filter(name => name !== CACHE_NAME)\n          .map(name => caches.delete(name))\n      );\n    })\n  );\n});\n\nself.addEventListener('fetch', event => {\n  // Ignore WebSocket requests for HMR and requests with chrome-extension scheme\n  const requestUrl = new URL(event.request.url);\n  if (event.request.url.includes('/ws') || requestUrl.protocol === 'chrome-extension:') {\n    return;\n  }\n\n  // Define destinations to use network-first strategy\n  const networkFirstDestinations = ['document', 'script', 'style'];\n\n  // For navigation, script, and style requests, use network-first strategy.\n  if (event.request.mode === 'navigate' || networkFirstDestinations.includes(event.request.destination)) {\n    event.respondWith(\n      fetch(event.request)\n        .then(response => {\n          console.log('[SW] Network fetch succeeded for:', event.request.url);\n          // Clone the response and update the cache\n          const clonedResponse = response.clone();\n          caches.open(CACHE_NAME).then(cache => {\n            cache.put(event.request, clonedResponse);\n          });\n          return response;\n        })\n        .catch(() => {\n          console.warn('[SW] Network fetch failed for:', event.request.url, ', attempting to serve from cache.');\n          // If network fetch fails, try to return the cached response\n          return caches.match(event.request).then(cachedResponse => {\n            if (cachedResponse) {\n              console.log('[SW] Serving cached response for:', event.request.url);\n              return cachedResponse;\n            }\n            // For navigation requests, fallback to cached index.html\n            if (event.request.mode === 'navigate') {\n              console.warn('[SW] No cached response found, serving cached index.html for navigation request.');\n              return caches.match(new URL('./index.html', self.location).toString());\n            }\n            console.error('[SW] No cached response available for:', event.request.url);\n            // Otherwise, return a 503 Service Unavailable response\n            return new Response('', {\n              status: 503,\n              statusText: 'Service Unavailable',\n              headers: { 'Content-Type': 'text/plain' }\n            });\n          });\n        })\n    );\n    return;\n  }\n\n  // For all other requests, use cache-first strategy\n  event.respondWith(\n    caches.match(event.request)\n      .then(response => {\n        if (response) {\n          console.log('[SW] Serving cached response for:', event.request.url);\n          return response;\n        }\n        return fetch(event.request)\n          .then(networkResponse => networkResponse)\n          .catch(() => {\n            console.error('[SW] Failed to fetch:', event.request.url);\n            return new Response('', {\n              status: 503,\n              statusText: 'Service Unavailable',\n              headers: { 'Content-Type': 'text/plain' }\n            });\n          });\n      })\n  );\n});\n"],"names":["CACHE_NAME","CDN_URLS","self","addEventListener","event","waitUntil","fetch","then","response","json","manifest","urlsFromManifest","Object","values","map","url","URL","location","toString","indexUrl","includes","push","allUrls","concat","caches","open","cache","Promise","all","urlObj","protocol","resolve","startsWith","Request","mode","put","catch","error","console","keys","cacheNames","filter","name","delete","requestUrl","request","networkFirstDestinations","destination","respondWith","log","clonedResponse","clone","warn","match","cachedResponse","Response","status","statusText","headers","networkResponse"],"version":3,"file":"sw.js.map"}