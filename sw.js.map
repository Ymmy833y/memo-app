{"mappings":"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","sources":["<anon>","src/sw.ts"],"sourcesContent":["/// <reference lib=\"webworker\" />\n// treat self as ServiceWorkerGlobalScope\nconst sw = self;\nconst CACHE_NAME = 'memo-app-cache-v3';\nconst ASSET_MANIFEST = './parcel-manifest.json';\n// List of external CDN URLs to cache\nconst CDN_URLS = [\n    'https://uicdn.toast.com/editor-plugin-code-syntax-highlight/latest/toastui-editor-plugin-code-syntax-highlight.min.css'\n];\n// --------------------------------------------------------------------------\n//  install\n// --------------------------------------------------------------------------\nsw.addEventListener('install', (event)=>{\n    event.waitUntil((async ()=>{\n        try {\n            // fetch parcel‑manifest.json\n            const response = await fetch(ASSET_MANIFEST);\n            const manifest = await response.json();\n            // convert files listed in manifest to absolute URLs\n            const urlsFromManifest = Object.values(manifest).map((url)=>new URL(url, self.location.href).toString());\n            // always include index.html\n            const indexUrl = new URL('./index.html', self.location.href).toString();\n            if (!urlsFromManifest.includes(indexUrl)) urlsFromManifest.push(indexUrl);\n            // combine local assets and CDN for caching\n            const allUrls = [\n                ...urlsFromManifest,\n                ...CDN_URLS\n            ];\n            const cache = await caches.open(CACHE_NAME);\n            await Promise.all(allUrls.map(async (url)=>{\n                const urlObj = new URL(url);\n                // skip chrome-extension scheme\n                if (urlObj.protocol === 'chrome-extension:') return;\n                try {\n                    // fetch toast CDN with no‑cors\n                    const request = url.startsWith('https://uicdn.toast.com/') ? new Request(url, {\n                        mode: 'no-cors'\n                    }) : new Request(url);\n                    const res = await fetch(request);\n                    await cache.put(url, res);\n                } catch (err) {\n                    console.error(`[SW] Failed to cache ${url}:`, err);\n                }\n            }));\n        } catch (err) {\n            console.error('[SW] Failed to load asset manifest:', err);\n        }\n    })());\n});\n// --------------------------------------------------------------------------\n//  activate\n// --------------------------------------------------------------------------\nsw.addEventListener('activate', (event)=>{\n    event.waitUntil((async ()=>{\n        const cacheNames = await caches.keys();\n        await Promise.all(cacheNames.filter((name)=>name !== CACHE_NAME).map((name)=>caches.delete(name)));\n    })());\n});\n// --------------------------------------------------------------------------\n//  fetch\n// --------------------------------------------------------------------------\nsw.addEventListener('fetch', (event)=>{\n    const { request } = event;\n    const requestUrl = new URL(request.url);\n    // ignore HMR WebSocket/chrome-extension\n    if (request.url.includes('/ws') || requestUrl.protocol === 'chrome-extension:') return;\n    // network first for document / script / style\n    const networkFirstTypes = [\n        'document',\n        'script',\n        'style'\n    ];\n    const isNetworkFirst = request.mode === 'navigate' || networkFirstTypes.includes(request.destination);\n    if (isNetworkFirst) {\n        event.respondWith((async ()=>{\n            try {\n                const networkResponse = await fetch(request);\n                // if fetched successfully, save to cache\n                const cache = await caches.open(CACHE_NAME);\n                cache.put(request, networkResponse.clone());\n                return networkResponse;\n            } catch  {\n                console.warn('[SW] Network fetch failed, falling back to cache:', request.url);\n                const cached = await caches.match(request);\n                if (cached) return cached;\n                // fallback for navigation: index.html\n                if (request.mode === 'navigate') return await caches.match(new URL('./index.html', self.location.href).toString());\n                return new Response('', {\n                    status: 503,\n                    statusText: 'Service Unavailable'\n                });\n            }\n        })());\n        return;\n    }\n    // ----------------------------- cache-first -----------------------------\n    event.respondWith((async ()=>{\n        const cached = await caches.match(request);\n        if (cached) {\n            console.log('[SW] Serving cached:', request.url);\n            return cached;\n        }\n        try {\n            return await fetch(request);\n        } catch  {\n            console.error('[SW] Fetch failed:', request.url);\n            return new Response('', {\n                status: 503,\n                statusText: 'Service Unavailable'\n            });\n        }\n    })());\n});\n\n//# sourceMappingURL=sw.js.map\n","/// <reference lib=\"webworker\" />\n\n// treat self as ServiceWorkerGlobalScope\nconst sw = self as unknown as ServiceWorkerGlobalScope;\n\nconst CACHE_NAME = 'memo-app-cache-v3' as const;\nconst ASSET_MANIFEST = './parcel-manifest.json' as const;\n\n// List of external CDN URLs to cache\nconst CDN_URLS = [\n  'https://uicdn.toast.com/editor-plugin-code-syntax-highlight/latest/toastui-editor-plugin-code-syntax-highlight.min.css'\n] as const;\n\n// --------------------------------------------------------------------------\n//  install\n// --------------------------------------------------------------------------\nsw.addEventListener('install', (event: ExtendableEvent) => {\n  event.waitUntil(\n    (async () => {\n      try {\n        // fetch parcel‑manifest.json\n        const response = await fetch(ASSET_MANIFEST);\n        const manifest: Record<string, string> = await response.json();\n\n        // convert files listed in manifest to absolute URLs\n        const urlsFromManifest = Object.values(manifest).map((url) =>\n          new URL(url, self.location.href).toString(),\n        );\n\n        // always include index.html\n        const indexUrl = new URL('./index.html', self.location.href).toString();\n        if (!urlsFromManifest.includes(indexUrl)) urlsFromManifest.push(indexUrl);\n\n        // combine local assets and CDN for caching\n        const allUrls = [...urlsFromManifest, ...CDN_URLS];\n\n        const cache = await caches.open(CACHE_NAME);\n        await Promise.all(\n          allUrls.map(async (url) => {\n            const urlObj = new URL(url);\n\n            // skip chrome-extension scheme\n            if (urlObj.protocol === 'chrome-extension:') return;\n\n            try {\n              // fetch toast CDN with no‑cors\n              const request =\n                url.startsWith('https://uicdn.toast.com/')\n                  ? new Request(url, { mode: 'no-cors' })\n                  : new Request(url);\n\n              const res = await fetch(request);\n              await cache.put(url, res);\n            } catch (err) {\n              console.error(`[SW] Failed to cache ${url}:`, err);\n            }\n          }),\n        );\n      } catch (err) {\n        console.error('[SW] Failed to load asset manifest:', err);\n      }\n    })(),\n  );\n});\n\n// --------------------------------------------------------------------------\n//  activate\n// --------------------------------------------------------------------------\nsw.addEventListener('activate', (event: ExtendableEvent) => {\n  event.waitUntil(\n    (async () => {\n      const cacheNames = await caches.keys();\n      await Promise.all(\n        cacheNames\n          .filter((name) => name !== CACHE_NAME)\n          .map((name) => caches.delete(name)),\n      );\n    })(),\n  );\n});\n\n// --------------------------------------------------------------------------\n//  fetch\n// --------------------------------------------------------------------------\nsw.addEventListener('fetch', (event: FetchEvent) => {\n  const { request } = event;\n  const requestUrl = new URL(request.url);\n\n  // ignore HMR WebSocket/chrome-extension\n  if (request.url.includes('/ws') || requestUrl.protocol === 'chrome-extension:')\n    return;\n\n  // network first for document / script / style\n  const networkFirstTypes: RequestDestination[] = ['document', 'script', 'style'];\n  const isNetworkFirst =\n    request.mode === 'navigate' || networkFirstTypes.includes(request.destination);\n\n  if (isNetworkFirst) {\n    event.respondWith(\n      (async () => {\n        try {\n          const networkResponse = await fetch(request);\n\n          // if fetched successfully, save to cache\n          const cache = await caches.open(CACHE_NAME);\n          cache.put(request, networkResponse.clone());\n\n          return networkResponse;\n        } catch {\n          console.warn('[SW] Network fetch failed, falling back to cache:', request.url);\n\n          const cached = await caches.match(request);\n          if (cached) return cached;\n\n          // fallback for navigation: index.html\n          if (request.mode === 'navigate') {\n            return (await caches.match(\n              new URL('./index.html', self.location.href).toString(),\n            )) as Response;\n          }\n\n          return new Response('', { status: 503, statusText: 'Service Unavailable' });\n        }\n      })(),\n    );\n    return;\n  }\n\n  // ----------------------------- cache-first -----------------------------\n  event.respondWith(\n    (async () => {\n      const cached = await caches.match(request);\n      if (cached) {\n        console.log('[SW] Serving cached:', request.url);\n        return cached;\n      }\n\n      try {\n        return await fetch(request);\n      } catch {\n        console.error('[SW] Fetch failed:', request.url);\n        return new Response('', { status: 503, statusText: 'Service Unavailable' });\n      }\n    })(),\n  );\n});\n"],"names":["sw","self","CACHE_NAME","ASSET_MANIFEST","CDN_URLS","addEventListener","event","waitUntil","response","fetch","manifest","json","urlsFromManifest","Object","values","map","url","URL","location","href","toString","indexUrl","includes","push","allUrls","cache","caches","open","Promise","all","urlObj","protocol","request","startsWith","Request","mode","res","put","err","console","error","cacheNames","keys","filter","name","delete","requestUrl","networkFirstTypes","destination","respondWith","networkResponse","clone","warn","cached","match","Response","status","statusText","log"],"version":3,"file":"sw.js.map"}